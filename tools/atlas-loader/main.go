package main

import (
	"fmt"
	"io"
	"os"
	"strings"

	"ariga.io/atlas-provider-gorm/gormschema"
	"github.com/flectolab/flecto-manager/database"
)

// uniqueIndexes defines composite unique indexes that cannot be expressed
// via GORM tags due to embedded struct limitations.
// Format: table_name -> index definition (without the trailing comma)
var uniqueIndexes = map[string]string{
	"agents":          "UNIQUE INDEX `idx_agents_namespace_project_name` (`namespace_code`, `project_code`, `name`)",
	"pages":           "UNIQUE INDEX `idx_pages_path_unique` (`namespace_code`, `project_code`, `path`)",
	"page_drafts":     "UNIQUE INDEX `idx_page_drafts_path_unique` (`namespace_code`, `project_code`, `new_path`)",
	"redirects":       "UNIQUE INDEX `idx_redirects_source_unique` (`namespace_code`, `project_code`, `source`)",
	"redirect_drafts": "UNIQUE INDEX `idx_redirect_drafts_source_unique` (`namespace_code`, `project_code`, `new_source`)",
	"projects":        "UNIQUE INDEX `idx_projects_namespace_project` (`namespace_code`, `project_code`)",
}

// removeConstraints lists FK constraints generated by gormschema that need to be
// removed (either incorrect direction or missing CASCADE).
var removeConstraints = []string{
	"fk_agents_project",
	"fk_pages_project",
	"fk_page_drafts_project",
	"fk_redirects_project",
	"fk_redirect_drafts_project",
	"fk_projects_namespace",
	"fk_pages_page_draft",
	"fk_redirects_redirect_draft",
}

// customForeignKeys defines FK constraints with correct direction and CASCADE.
// These replace the incorrectly generated constraints.
var customForeignKeys = []string{
	// Project hierarchy: Namespace -> Project -> Resources
	"ALTER TABLE `projects` ADD CONSTRAINT `fk_projects_namespace` FOREIGN KEY (`namespace_code`) REFERENCES `namespaces`(`namespace_code`) ON DELETE CASCADE;",
	"ALTER TABLE `agents` ADD CONSTRAINT `fk_agents_project` FOREIGN KEY (`namespace_code`,`project_code`) REFERENCES `projects`(`namespace_code`,`project_code`) ON DELETE CASCADE;",
	"ALTER TABLE `pages` ADD CONSTRAINT `fk_pages_project` FOREIGN KEY (`namespace_code`,`project_code`) REFERENCES `projects`(`namespace_code`,`project_code`) ON DELETE CASCADE;",
	"ALTER TABLE `page_drafts` ADD CONSTRAINT `fk_page_drafts_project` FOREIGN KEY (`namespace_code`,`project_code`) REFERENCES `projects`(`namespace_code`,`project_code`) ON DELETE CASCADE;",
	"ALTER TABLE `redirects` ADD CONSTRAINT `fk_redirects_project` FOREIGN KEY (`namespace_code`,`project_code`) REFERENCES `projects`(`namespace_code`,`project_code`) ON DELETE CASCADE;",
	"ALTER TABLE `redirect_drafts` ADD CONSTRAINT `fk_redirect_drafts_project` FOREIGN KEY (`namespace_code`,`project_code`) REFERENCES `projects`(`namespace_code`,`project_code`) ON DELETE CASCADE;",
	"ALTER TABLE `page_drafts` ADD CONSTRAINT `fk_pages_page_draft` FOREIGN KEY (`old_page_id`) REFERENCES `pages`(`id`) ON DELETE CASCADE;",
	"ALTER TABLE `redirect_drafts` ADD CONSTRAINT `fk_redirects_redirect_draft` FOREIGN KEY (`old_redirect_id`) REFERENCES `redirects`(`id`) ON DELETE CASCADE;",
}

func main() {
	stmts, err := gormschema.New("mysql").Load(database.Models...)
	if err != nil {
		fmt.Fprintf(os.Stderr, "failed to load gorm schema: %v\n", err)
		os.Exit(1)
	}

	// Add unique indexes to the generated SQL
	stmts = addUniqueIndexes(stmts)

	// Remove incorrectly generated FK constraints
	stmts = removeIncorrectConstraints(stmts)

	// Add correct FK constraints
	stmts = addCustomForeignKeys(stmts)

	io.WriteString(os.Stdout, stmts)
}

// addUniqueIndexes injects unique index definitions into CREATE TABLE statements
func addUniqueIndexes(sql string) string {
	for table, indexDef := range uniqueIndexes {
		// Find the CREATE TABLE statement for this table
		tableMarker := fmt.Sprintf("CREATE TABLE `%s`", table)
		tableStart := strings.Index(sql, tableMarker)
		if tableStart == -1 {
			continue
		}

		// Find the closing ");" of the CREATE TABLE
		tableEnd := strings.Index(sql[tableStart:], ");")
		if tableEnd == -1 {
			continue
		}

		// Insert position is just before the ");"
		insertPos := tableStart + tableEnd

		// Insert ",UNIQUE INDEX ..." before the closing ");"
		indexInsert := "," + indexDef
		sql = sql[:insertPos] + indexInsert + sql[insertPos:]
	}

	return sql
}

// removeIncorrectConstraints removes FK constraints that gormschema generated
// with incorrect direction (e.g., projects referencing redirects instead of vice versa)
func removeIncorrectConstraints(sql string) string {
	for _, constraint := range removeConstraints {
		// Find the full ALTER TABLE statement for this constraint
		marker := fmt.Sprintf("CONSTRAINT `%s` FOREIGN KEY", constraint)
		pos := strings.Index(sql, marker)
		if pos == -1 {
			continue
		}

		// Find the start of this ALTER TABLE statement
		stmtStart := strings.LastIndex(sql[:pos], "ALTER TABLE")
		if stmtStart == -1 {
			continue
		}

		// Find the end of this statement (the semicolon + newline)
		stmtEnd := strings.Index(sql[pos:], ";")
		if stmtEnd == -1 {
			continue
		}
		stmtEnd = pos + stmtEnd + 1

		// Skip any trailing newline
		if stmtEnd < len(sql) && sql[stmtEnd] == '\n' {
			stmtEnd++
		}

		// Remove the entire statement
		sql = sql[:stmtStart] + sql[stmtEnd:]
	}

	return sql
}

// addCustomForeignKeys appends the correct FK constraints at the end of the SQL
func addCustomForeignKeys(sql string) string {
	for _, fk := range customForeignKeys {
		sql += "\n" + fk
	}
	return sql
}
