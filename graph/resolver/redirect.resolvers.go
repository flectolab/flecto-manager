package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"fmt"

	"github.com/flectolab/flecto-manager/auth"
	"github.com/flectolab/flecto-manager/common/types"
	"github.com/flectolab/flecto-manager/database"
	"github.com/flectolab/flecto-manager/graph"
	"github.com/flectolab/flecto-manager/model"
)

// ProjectsRedirects is the resolver for the projectsRedirects field.
func (r *queryResolver) ProjectsRedirects(ctx context.Context, namespaceCode string, projectCode string, pagination *types.PaginationInput, filter *graph.RedirectFilter, sort []database.SortInput) (*types.PaginatedResult[model.Redirect], error) {
	userCtx := auth.GetUser(ctx)
	if !r.PermissionChecker.CanResource(userCtx.SubjectPermissions, namespaceCode, projectCode, model.ResourceTypeRedirect, model.ActionRead) {
		return nil, fmt.Errorf("user %s has no permission to access project %s/%s", userCtx.Username, namespaceCode, projectCode)
	}
	query := r.RedirectService.GetQuery(ctx).
		Joins("LEFT JOIN redirect_drafts ON redirect_drafts.old_redirect_id = redirects.id").
		Where(fmt.Sprintf("redirects.%s = ? AND redirects.%s = ?", model.ColumnNamespaceCode, model.ColumnProjectCode), namespaceCode, projectCode)

	if filter != nil {
		if filter.Search != nil && *filter.Search != "" {
			search := "%" + *filter.Search + "%"
			query = query.Where(
				"redirects.source LIKE ? OR redirects.target LIKE ? OR redirect_drafts.new_source LIKE ? OR redirect_drafts.new_target LIKE ?",
				search, search, search, search,
			)
		}
		if len(filter.Types) > 0 {
			query = query.Where("redirects.type IN ?", filter.Types)
		}
		if len(filter.Status) > 0 {
			query = query.Where("redirects.status IN ?", filter.Status)
		}
		if len(filter.DraftStatus) > 0 {
			// Build conditions for draft status filtering
			// DraftStatus can include CREATE, UPDATE, DELETE (from draft) or PUBLISHED (no draft)
			var hasDraftTypes []model.DraftChangeType
			includePublished := false

			for _, status := range filter.DraftStatus {
				if status == model.DraftChangeTypePublished {
					includePublished = true
				} else {
					hasDraftTypes = append(hasDraftTypes, status)
				}
			}

			if len(hasDraftTypes) > 0 && includePublished {
				query = query.Where("redirect_drafts.change_type IN ? OR redirect_drafts.change_type IS NULL", hasDraftTypes)
			} else if len(hasDraftTypes) > 0 {
				query = query.Where("redirect_drafts.change_type IN ?", hasDraftTypes)
			} else if includePublished {
				query = query.Where("redirect_drafts.change_type IS NULL")
			}
		}
	}

	// Apply sorting
	if len(sort) > 0 {
		query = database.ApplySort(query, model.RedirectSortableColumns, sort, "redirects")
	}

	return r.RedirectService.SearchPaginate(ctx, pagination, query)
}

// ProjectRedirect is the resolver for the projectRedirect field.
func (r *queryResolver) ProjectRedirect(ctx context.Context, namespaceCode string, projectCode string, redirectID int64) (*model.Redirect, error) {
	userCtx := auth.GetUser(ctx)
	if !r.PermissionChecker.CanResource(userCtx.SubjectPermissions, namespaceCode, projectCode, model.ResourceTypeRedirect, model.ActionRead) {
		return nil, fmt.Errorf("user %s has no permission to access project %s/%s", userCtx.Username, namespaceCode, projectCode)
	}

	return r.RedirectService.GetByID(ctx, namespaceCode, projectCode, redirectID)
}
