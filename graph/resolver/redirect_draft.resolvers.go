package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"fmt"
	"net/url"

	"github.com/99designs/gqlgen/graphql"
	"github.com/flectolab/flecto-manager/auth"
	commonTypes "github.com/flectolab/flecto-manager/common/types"
	"github.com/flectolab/flecto-manager/graph"
	"github.com/flectolab/flecto-manager/model"
	"github.com/flectolab/flecto-manager/service"
)

// CreateRedirectDraft is the resolver for the createRedirectDraft field.
func (r *mutationResolver) CreateRedirectDraft(ctx context.Context, namespaceCode string, projectCode string, input graph.CreateRedirectDraft) (*model.RedirectDraft, error) {
	userCtx := auth.GetUser(ctx)
	if !r.PermissionChecker.CanResource(userCtx.SubjectPermissions, namespaceCode, projectCode, model.ResourceTypeRedirect, model.ActionWrite) {
		return nil, fmt.Errorf("user %s has no permission to access project %s/%s", userCtx.Username, namespaceCode, projectCode)
	}

	return r.RedirectDraftService.Create(ctx, namespaceCode, projectCode, input.OldRedirectID, input.NewRedirect)
}

// UpdateRedirectDraft is the resolver for the updateRedirectDraft field.
func (r *mutationResolver) UpdateRedirectDraft(ctx context.Context, namespaceCode string, projectCode string, redirectDraftID int64, input graph.UpdateRedirectDraft) (*model.RedirectDraft, error) {
	userCtx := auth.GetUser(ctx)
	if !r.PermissionChecker.CanResource(userCtx.SubjectPermissions, namespaceCode, projectCode, model.ResourceTypeRedirect, model.ActionWrite) {
		return nil, fmt.Errorf("user %s has no permission to access project %s/%s", userCtx.Username, namespaceCode, projectCode)
	}
	return r.RedirectDraftService.Update(ctx, redirectDraftID, input.NewRedirect)
}

// DeleteRedirectDraft is the resolver for the deleteRedirectDraft field.
func (r *mutationResolver) DeleteRedirectDraft(ctx context.Context, namespaceCode string, projectCode string, redirectDraftID int64) (bool, error) {
	userCtx := auth.GetUser(ctx)
	if !r.PermissionChecker.CanResource(userCtx.SubjectPermissions, namespaceCode, projectCode, model.ResourceTypeRedirect, model.ActionWrite) {
		return false, fmt.Errorf("user %s has no permission to access project %s/%s", userCtx.Username, namespaceCode, projectCode)
	}

	return r.RedirectDraftService.Delete(ctx, redirectDraftID)
}

// RollbackRedirectDraft is the resolver for the rollbackRedirectDraft field.
func (r *mutationResolver) RollbackRedirectDraft(ctx context.Context, namespaceCode string, projectCode string) (bool, error) {
	userCtx := auth.GetUser(ctx)
	if !r.PermissionChecker.CanResource(userCtx.SubjectPermissions, namespaceCode, projectCode, model.ResourceTypeRedirect, model.ActionWrite) {
		return false, fmt.Errorf("user %s has no permission to access project %s/%s", userCtx.Username, namespaceCode, projectCode)
	}

	return r.RedirectDraftService.Rollback(ctx, namespaceCode, projectCode)
}

// ImportRedirectDraft is the resolver for the importRedirectDraft field.
func (r *mutationResolver) ImportRedirectDraft(ctx context.Context, namespaceCode string, projectCode string, file graphql.Upload, input *graph.ImportRedirectInput) (*graph.ImportRedirectResult, error) {
	userCtx := auth.GetUser(ctx)
	if !r.PermissionChecker.CanResource(userCtx.SubjectPermissions, namespaceCode, projectCode, model.ResourceTypeRedirect, model.ActionWrite) {
		return nil, fmt.Errorf("user %s has no permission to access project %s/%s", userCtx.Username, namespaceCode, projectCode)
	}

	// Validate file
	if err := r.RedirectImportService.ValidateFile(file.Filename, file.ContentType, file.Size); err != nil {
		return nil, err
	}

	// Parse file
	parsedRows, parseErrors, err := r.RedirectImportService.ParseFile(file.File)
	if err != nil {
		return nil, err
	}

	// Build import options
	opts := service.ImportRedirectOptions{
		Overwrite: true, // Default to true
	}
	if input != nil {
		opts.Overwrite = input.Overwrite
	}

	// Import rows
	importResult, err := r.RedirectImportService.Import(ctx, namespaceCode, projectCode, parsedRows, opts)
	if err != nil {
		return nil, err
	}

	// Convert service errors to GraphQL errors
	graphErrors := make([]graph.ImportRedirectError, 0, len(parseErrors)+len(importResult.Errors))

	// Add parse errors
	for _, e := range parseErrors {
		graphErrors = append(graphErrors, graph.ImportRedirectError{
			Line:    e.Line,
			Source:  strPtrOrNil(e.Source),
			Target:  strPtrOrNil(e.Target),
			Reason:  convertErrorReason(e.Reason),
			Message: e.Message,
		})
	}

	// Add import errors
	for _, e := range importResult.Errors {
		graphErrors = append(graphErrors, graph.ImportRedirectError{
			Line:    e.Line,
			Source:  strPtrOrNil(e.Source),
			Target:  strPtrOrNil(e.Target),
			Reason:  convertErrorReason(e.Reason),
			Message: e.Message,
		})
	}

	totalLines := len(parsedRows) + len(parseErrors)

	return &graph.ImportRedirectResult{
		Success:       importResult.Success && len(parseErrors) == 0,
		TotalLines:    totalLines,
		ImportedCount: importResult.ImportedCount,
		SkippedCount:  importResult.SkippedCount,
		ErrorCount:    len(parseErrors) + importResult.ErrorCount,
		Errors:        graphErrors,
	}, nil
}

// ProjectsRedirectDrafts is the resolver for the projectsRedirectDrafts field.
func (r *queryResolver) ProjectsRedirectDrafts(ctx context.Context, namespaceCode string, projectCode string, pagination *commonTypes.PaginationInput, filter *graph.RedirectDraftFilter) (*commonTypes.PaginatedResult[model.RedirectDraft], error) {
	userCtx := auth.GetUser(ctx)
	if !r.PermissionChecker.CanResource(userCtx.SubjectPermissions, namespaceCode, projectCode, model.ResourceTypeRedirect, model.ActionRead) {
		return nil, fmt.Errorf("user %s has no permission to access project %s/%s", userCtx.Username, namespaceCode, projectCode)
	}
	query := r.RedirectDraftService.GetQuery(ctx).Preload("OldRedirect").
		Where(fmt.Sprintf("%s = ? AND %s = ?", model.ColumnNamespaceCode, model.ColumnProjectCode), namespaceCode, projectCode)

	return r.RedirectDraftService.SearchPaginate(ctx, pagination, query)
}

// ProjectRedirectDraft is the resolver for the projectRedirectDraft field.
func (r *queryResolver) ProjectRedirectDraft(ctx context.Context, namespaceCode string, projectCode string, redirectDraftID int64) (*model.RedirectDraft, error) {
	userCtx := auth.GetUser(ctx)
	if !r.PermissionChecker.CanResource(userCtx.SubjectPermissions, namespaceCode, projectCode, model.ResourceTypeRedirect, model.ActionRead) {
		return nil, fmt.Errorf("user %s has no permission to access project %s/%s", userCtx.Username, namespaceCode, projectCode)
	}

	return r.RedirectDraftService.GetByID(ctx, redirectDraftID)
}

// ProjectRedirectDraftCheck is the resolver for the projectRedirectDraftCheck field.
func (r *queryResolver) ProjectRedirectDraftCheck(ctx context.Context, namespaceCode string, projectCode string, redirectCheck graph.RedirectCheck, scope *graph.RedirectScope) ([]graph.RedirectCheckResult, error) {
	userCtx := auth.GetUser(ctx)
	if !r.PermissionChecker.CanResource(userCtx.SubjectPermissions, namespaceCode, projectCode, model.ResourceTypeRedirect, model.ActionRead) {
		return nil, fmt.Errorf("user %s has no permission to access project %s/%s", userCtx.Username, namespaceCode, projectCode)
	}
	var err error
	treeMatcher := commonTypes.NewRedirectTreeMatcher()
	if *scope != graph.RedirectScopeSingle {
		redirects, errGetRedirects := r.RedirectService.FindByProject(ctx, namespaceCode, projectCode)
		if errGetRedirects != nil {
			return nil, errGetRedirects
		}
		for _, redirect := range redirects {
			if *scope == graph.RedirectScopeProjectWithDraft && redirect.RedirectDraft != nil {
				err = treeMatcher.Insert(redirect.RedirectDraft.NewRedirect)
			} else if *scope == graph.RedirectScopeProject && !*redirect.IsPublished {
				continue
			} else {
				err = treeMatcher.Insert(redirect.Redirect)
			}
			if err != nil {
				return nil, err
			}
		}
	}

	if redirectCheck.Redirect != nil {
		err = treeMatcher.Insert(redirectCheck.Redirect)
		if err != nil {
			return nil, err
		}
	}

	redirectCheckResults := make([]graph.RedirectCheckResult, 0)
	for _, urlTest := range redirectCheck.Urls {
		u, errParse := url.Parse(urlTest)
		if errParse != nil {
			return nil, errParse
		}
		redirect, target := treeMatcher.Match(u.Host, u.RequestURI())
		redirectCheckResults = append(redirectCheckResults, graph.RedirectCheckResult{
			URL:             urlTest,
			RedirectMatched: redirect,
			Matched:         redirect != nil,
			Target:          target,
		})
	}

	return redirectCheckResults, nil
}
