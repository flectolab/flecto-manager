package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"fmt"
	"time"

	"github.com/flectolab/flecto-manager/auth"
	commonTypes "github.com/flectolab/flecto-manager/common/types"
	"github.com/flectolab/flecto-manager/database"
	"github.com/flectolab/flecto-manager/graph"
	"github.com/flectolab/flecto-manager/model"
)

// CreateProject is the resolver for the createProject field.
func (r *mutationResolver) CreateProject(ctx context.Context, namespaceCode string, input *graph.CreateProjectInput) (*model.Project, error) {
	userCtx := auth.GetUser(ctx)
	if !r.PermissionChecker.CanAdmin(userCtx.SubjectPermissions, model.AdminSectionProjects, model.ActionWrite) {
		return nil, fmt.Errorf("user %s has no permission to access %s", userCtx.Username, model.AdminSectionProjects)
	}

	newProject := &model.Project{
		NamespaceCode: namespaceCode,
		ProjectCode:   input.ProjectCode,
		Name:          input.Name,
	}

	return r.ProjectService.Create(ctx, newProject)
}

// UpdateProject is the resolver for the updateProject field.
func (r *mutationResolver) UpdateProject(ctx context.Context, namespaceCode string, projectCode string, input *graph.UpdateProjectInput) (*model.Project, error) {
	userCtx := auth.GetUser(ctx)
	if !r.PermissionChecker.CanAdmin(userCtx.SubjectPermissions, model.AdminSectionProjects, model.ActionWrite) {
		return nil, fmt.Errorf("user %s has no permission to access %s", userCtx.Username, model.AdminSectionProjects)
	}
	return r.ProjectService.Update(ctx, namespaceCode, projectCode, model.Project{Name: input.Name})
}

// DeleteProject is the resolver for the deleteProject field.
func (r *mutationResolver) DeleteProject(ctx context.Context, namespaceCode string, projectCode string) (bool, error) {
	userCtx := auth.GetUser(ctx)
	if !r.PermissionChecker.CanAdmin(userCtx.SubjectPermissions, model.AdminSectionProjects, model.ActionWrite) {
		return false, fmt.Errorf("user %s has no permission to access %s", userCtx.Username, model.AdminSectionProjects)
	}

	return r.ProjectService.Delete(ctx, namespaceCode, projectCode)
}

// PublishProject is the resolver for the publish field.
func (r *mutationResolver) PublishProject(ctx context.Context, namespaceCode string, projectCode string) (*model.Project, error) {
	userCtx := auth.GetUser(ctx)
	if !r.PermissionChecker.CanResource(userCtx.SubjectPermissions, namespaceCode, projectCode, model.ResourceTypeAll, model.ActionWrite) {
		return nil, fmt.Errorf("user %s has no permission to access project %s/%s", userCtx.Username, namespaceCode, projectCode)
	}

	return r.ProjectService.Publish(ctx, namespaceCode, projectCode)
}

// CountRedirects is the resolver for the countRedirects field.
func (r *projectResolver) CountRedirects(ctx context.Context, obj *model.Project) (int64, error) {
	return r.ProjectService.CountRedirects(ctx, obj.NamespaceCode, obj.ProjectCode)
}

// CountRedirectDrafts is the resolver for the countRedirectDrafts field.
func (r *projectResolver) CountRedirectDrafts(ctx context.Context, obj *model.Project) (int64, error) {
	return r.ProjectService.CountRedirectDrafts(ctx, obj.NamespaceCode, obj.ProjectCode)
}

// CountPages is the resolver for the countPages field.
func (r *projectResolver) CountPages(ctx context.Context, obj *model.Project) (int64, error) {
	return r.ProjectService.CountPages(ctx, obj.NamespaceCode, obj.ProjectCode)
}

// CountPageDrafts is the resolver for the countPageDrafts field.
func (r *projectResolver) CountPageDrafts(ctx context.Context, obj *model.Project) (int64, error) {
	return r.ProjectService.CountPageDrafts(ctx, obj.NamespaceCode, obj.ProjectCode)
}

// TotalPageContentSize is the resolver for the totalPageContentSize field.
func (r *projectResolver) TotalPageContentSize(ctx context.Context, obj *model.Project) (int64, error) {
	return r.ProjectService.TotalPageContentSize(ctx, obj.NamespaceCode, obj.ProjectCode)
}

// TotalPageContentSizeLimit is the resolver for the totalPageContentSizeLimit field.
func (r *projectResolver) TotalPageContentSizeLimit(ctx context.Context, obj *model.Project) (int64, error) {
	return r.ProjectService.TotalPageContentSizeLimit(), nil
}

// CountAgentError is the resolver for the countAgentError field.
func (r *projectResolver) CountAgentError(ctx context.Context, obj *model.Project) (int64, error) {
	updatedAfter := time.Now().Add(-r.AgentConfig.OfflineThreshold)
	return r.AgentService.CountByProjectAndStatus(ctx, obj.NamespaceCode, obj.ProjectCode, commonTypes.AgentStatusError, updatedAfter)
}

// SearchProjects is the resolver for the searchProjects field.
func (r *queryResolver) SearchProjects(ctx context.Context, pagination *commonTypes.PaginationInput, filter graph.ProjectFilter, sort []database.SortInput) (*commonTypes.PaginatedResult[model.Project], error) {
	userCtx := auth.GetUser(ctx)
	query := r.ProjectService.GetQuery(ctx)
	if !r.PermissionChecker.CanAdmin(userCtx.SubjectPermissions, model.AdminSectionProjects, model.ActionRead) {
		query = r.PermissionChecker.FilterQueryByNamespace(query, userCtx.SubjectPermissions.Resources, model.ActionRead)
	}

	if filter.Search != nil && *filter.Search != "" {
		search := fmt.Sprintf("%%%s%%", *filter.Search)
		query = query.Where(fmt.Sprintf("%s LIKE ? OR %s LIKE ? OR name LIKE ?", model.ColumnNamespaceCode, model.ColumnProjectCode), search, search, search)
	}

	if filter.NamespaceCode != nil && *filter.NamespaceCode != "" {
		query = query.Where(fmt.Sprintf("%s = ?", model.ColumnNamespaceCode), filter.NamespaceCode)
	}

	if len(sort) > 0 {
		query = database.ApplySort(query, model.ProjectSortableColumns, sort, "")
	}

	return r.ProjectService.SearchPaginate(ctx, pagination, query)
}

// Project is the resolver for the project field.
func (r *queryResolver) Project(ctx context.Context, namespaceCode string, projectCode string) (*model.Project, error) {
	userCtx := auth.GetUser(ctx)
	if !r.PermissionChecker.CanAdmin(userCtx.SubjectPermissions, model.AdminSectionProjects, model.ActionRead) &&
		!r.PermissionChecker.CanResource(userCtx.SubjectPermissions, namespaceCode, projectCode, model.ResourceTypeAll, model.ActionRead) {
		return nil, fmt.Errorf("user %s has no permission to access project %s/%s", userCtx.Username, namespaceCode, projectCode)
	}
	return r.ProjectService.GetByCodeWithNamespace(ctx, namespaceCode, projectCode)
}

// Project returns graph.ProjectResolver implementation.
func (r *Resolver) Project() graph.ProjectResolver { return &projectResolver{r} }

type projectResolver struct{ *Resolver }
