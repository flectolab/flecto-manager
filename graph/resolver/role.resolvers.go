package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"fmt"

	"github.com/flectolab/flecto-manager/auth"
	"github.com/flectolab/flecto-manager/common/types"
	"github.com/flectolab/flecto-manager/database"
	"github.com/flectolab/flecto-manager/graph"
	"github.com/flectolab/flecto-manager/model"
)

// Section is the resolver for the section field.
func (r *adminPermissionResolver) Section(ctx context.Context, obj *model.AdminPermission) (string, error) {
	return string(obj.Section), nil
}

// Action is the resolver for the action field.
func (r *adminPermissionResolver) Action(ctx context.Context, obj *model.AdminPermission) (string, error) {
	return string(obj.Action), nil
}

// CreateRole is the resolver for the createRole field.
func (r *mutationResolver) CreateRole(ctx context.Context, input graph.CreateRoleInput) (*model.Role, error) {
	userCtx := auth.GetUser(ctx)
	if !r.PermissionChecker.CanAdmin(userCtx.SubjectPermissions, model.AdminSectionRoles, model.ActionWrite) {
		return nil, fmt.Errorf("user %s has no permission to access %s", userCtx.Username, model.AdminSectionRoles)
	}

	// Validate role code: only alphanumeric, underscore and hyphen allowed
	if !model.ValidRoleNameRegex.MatchString(input.Code) {
		return nil, fmt.Errorf("invalid role code: only alphanumeric characters, underscores and hyphens are allowed")
	}

	// Check if role already exists
	existingRole, _ := r.RoleService.GetByCode(ctx, input.Code, model.RoleTypeRole)
	if existingRole != nil {
		return nil, fmt.Errorf("role %s already exists", input.Code)
	}

	// Create the role
	role, err := r.RoleService.Create(ctx, &model.Role{Code: input.Code, Type: model.RoleTypeRole})
	if err != nil {
		return nil, err
	}

	// Set permissions if provided
	subjectPermissions := &model.SubjectPermissions{}
	for _, permission := range input.ResourcePermissions {
		subjectPermissions.Resources = append(subjectPermissions.Resources, model.ResourcePermission{
			Namespace: permission.Namespace,
			Project:   permission.Project,
			Resource:  model.ResourceType(permission.Resource),
			Action:    model.ActionType(permission.Action),
		})
	}
	for _, permission := range input.AdminPermissions {
		subjectPermissions.Admin = append(subjectPermissions.Admin, model.AdminPermission{Section: model.SectionType(permission.Section), Action: model.ActionType(permission.Action)})
	}

	if len(subjectPermissions.Resources) > 0 || len(subjectPermissions.Admin) > 0 {
		err = r.RoleService.UpdateRolePermissions(ctx, role.ID, subjectPermissions)
		if err != nil {
			return nil, err
		}
	}

	role.Resources = subjectPermissions.Resources
	role.Admin = subjectPermissions.Admin
	return role, nil
}

// UpdateRole is the resolver for the updateRole field.
func (r *mutationResolver) UpdateRole(ctx context.Context, code string, input graph.UpdateRoleInput) (*model.Role, error) {
	userCtx := auth.GetUser(ctx)
	if !r.PermissionChecker.CanAdmin(userCtx.SubjectPermissions, model.AdminSectionRoles, model.ActionWrite) {
		return nil, fmt.Errorf("user %s has no permission to access %s", userCtx.Username, model.AdminSectionRoles)
	}

	// Get existing role
	role, err := r.RoleService.GetByCode(ctx, code, model.RoleTypeRole)
	if err != nil {
		return nil, fmt.Errorf("role %s not found", code)
	}

	// Update permissions
	subjectPermissions := &model.SubjectPermissions{}
	for _, permission := range input.ResourcePermissions {
		subjectPermissions.Resources = append(
			subjectPermissions.Resources,
			model.ResourcePermission{
				Namespace: permission.Namespace,
				Project:   permission.Project,
				Resource:  model.ResourceType(permission.Resource),
				Action:    model.ActionType(permission.Action),
			},
		)
	}
	for _, permission := range input.AdminPermissions {
		subjectPermissions.Admin = append(
			subjectPermissions.Admin,
			model.AdminPermission{
				Section: model.SectionType(permission.Section),
				Action:  model.ActionType(permission.Action),
			},
		)
	}

	err = r.RoleService.UpdateRolePermissions(ctx, role.ID, subjectPermissions)
	if err != nil {
		return nil, err
	}

	// Fetch updated role to get new timestamps and permissions
	role, _ = r.RoleService.GetByCode(ctx, code, model.RoleTypeRole)
	return role, nil
}

// DeleteRole is the resolver for the deleteRole field.
func (r *mutationResolver) DeleteRole(ctx context.Context, code string) (bool, error) {
	userCtx := auth.GetUser(ctx)
	if !r.PermissionChecker.CanAdmin(userCtx.SubjectPermissions, model.AdminSectionRoles, model.ActionWrite) {
		return false, fmt.Errorf("user %s has no permission to delete %s", userCtx.Username, model.AdminSectionRoles)
	}

	role, err := r.RoleService.GetByCode(ctx, code, model.RoleTypeRole)
	if err != nil {
		return false, err
	}

	return r.RoleService.Delete(ctx, role.ID)
}

// AddUserToRole is the resolver for the addUserToRole field.
func (r *mutationResolver) AddUserToRole(ctx context.Context, roleCode string, userID int64) (bool, error) {
	userCtx := auth.GetUser(ctx)
	if !r.PermissionChecker.CanAdmin(userCtx.SubjectPermissions, model.AdminSectionRoles, model.ActionWrite) {
		return false, fmt.Errorf("user %s has no permission to modify %s", userCtx.Username, model.AdminSectionRoles)
	}

	role, err := r.RoleService.GetByCode(ctx, roleCode, model.RoleTypeRole)
	if err != nil {
		return false, err
	}

	if err := r.RoleService.AddUserToRole(ctx, userID, role.ID); err != nil {
		return false, err
	}

	return true, nil
}

// RemoveUserFromRole is the resolver for the removeUserFromRole field.
func (r *mutationResolver) RemoveUserFromRole(ctx context.Context, roleCode string, userID int64) (bool, error) {
	userCtx := auth.GetUser(ctx)
	if !r.PermissionChecker.CanAdmin(userCtx.SubjectPermissions, model.AdminSectionRoles, model.ActionWrite) {
		return false, fmt.Errorf("user %s has no permission to modify %s", userCtx.Username, model.AdminSectionRoles)
	}

	role, err := r.RoleService.GetByCode(ctx, roleCode, model.RoleTypeRole)
	if err != nil {
		return false, err
	}

	if err := r.RoleService.RemoveUserFromRole(ctx, userID, role.ID); err != nil {
		return false, err
	}

	return true, nil
}

// Roles is the resolver for the roles field.
func (r *queryResolver) Roles(ctx context.Context) ([]model.Role, error) {
	userCtx := auth.GetUser(ctx)
	if !r.PermissionChecker.CanAdmin(userCtx.SubjectPermissions, model.AdminSectionRoles, model.ActionRead) {
		return nil, fmt.Errorf("user %s has no permission to access %s", userCtx.Username, model.AdminSectionRoles)
	}
	return r.RoleService.GetAllByType(ctx, model.RoleTypeRole)
}

// Role is the resolver for the role field.
func (r *queryResolver) Role(ctx context.Context, code string) (*model.Role, error) {
	userCtx := auth.GetUser(ctx)
	if !r.PermissionChecker.CanAdmin(userCtx.SubjectPermissions, model.AdminSectionRoles, model.ActionRead) {
		return nil, fmt.Errorf("user %s has no permission to access %s", userCtx.Username, model.AdminSectionRoles)
	}
	return r.RoleService.GetByCode(ctx, code, model.RoleTypeRole)
}

// SearchRoles is the resolver for the searchRoles field.
func (r *queryResolver) SearchRoles(ctx context.Context, pagination *types.PaginationInput, filter graph.RoleFilter, sort []database.SortInput) (*types.PaginatedResult[model.Role], error) {
	userCtx := auth.GetUser(ctx)
	if !r.PermissionChecker.CanAdmin(userCtx.SubjectPermissions, model.AdminSectionRoles, model.ActionRead) {
		return nil, fmt.Errorf("user %s has no permission to access %s", userCtx.Username, model.AdminSectionRoles)
	}
	query := r.RoleService.GetQuery(ctx).Where("type = ?", model.RoleTypeRole)

	if filter.Search != nil && *filter.Search != "" {
		search := fmt.Sprintf("%%%s%%", *filter.Search)
		query = query.Where("code LIKE ?", search)
	}

	if len(sort) > 0 {
		query = database.ApplySort(query, model.RoleSortableColumns, sort, "")
	}

	return r.RoleService.SearchPaginate(ctx, pagination, query)
}

// RoleUsers is the resolver for the roleUsers field.
func (r *queryResolver) RoleUsers(ctx context.Context, code string, pagination *types.PaginationInput, filter *graph.RoleUsersFilter, sort []database.SortInput) (*types.PaginatedResult[model.User], error) {
	userCtx := auth.GetUser(ctx)
	if !r.PermissionChecker.CanAdmin(userCtx.SubjectPermissions, model.AdminSectionRoles, model.ActionRead) {
		return nil, fmt.Errorf("user %s has no permission to access %s", userCtx.Username, model.AdminSectionRoles)
	}

	search := ""
	if filter != nil && filter.Search != nil {
		search = *filter.Search
	}

	return r.RoleService.GetRoleUsersPaginate(ctx, code, pagination, search)
}

// UsersNotInRole is the resolver for the usersNotInRole field.
func (r *queryResolver) UsersNotInRole(ctx context.Context, code string, search string, limit *int) ([]model.User, error) {
	userCtx := auth.GetUser(ctx)
	if !r.PermissionChecker.CanAdmin(userCtx.SubjectPermissions, model.AdminSectionRoles, model.ActionRead) {
		return nil, fmt.Errorf("user %s has no permission to access %s", userCtx.Username, model.AdminSectionRoles)
	}

	l := 10
	if limit != nil && *limit > 0 {
		l = *limit
	}

	return r.RoleService.GetUsersNotInRole(ctx, code, search, l)
}

// Resource is the resolver for the resource field.
func (r *resourcePermissionResolver) Resource(ctx context.Context, obj *model.ResourcePermission) (string, error) {
	return string(obj.Resource), nil
}

// Action is the resolver for the action field.
func (r *resourcePermissionResolver) Action(ctx context.Context, obj *model.ResourcePermission) (string, error) {
	return string(obj.Action), nil
}

// Type is the resolver for the type field.
func (r *roleResolver) Type(ctx context.Context, obj *model.Role) (string, error) {
	return string(obj.Type), nil
}

// AdminPermission returns graph.AdminPermissionResolver implementation.
func (r *Resolver) AdminPermission() graph.AdminPermissionResolver {
	return &adminPermissionResolver{r}
}

// ResourcePermission returns graph.ResourcePermissionResolver implementation.
func (r *Resolver) ResourcePermission() graph.ResourcePermissionResolver {
	return &resourcePermissionResolver{r}
}

// Role returns graph.RoleResolver implementation.
func (r *Resolver) Role() graph.RoleResolver { return &roleResolver{r} }

type adminPermissionResolver struct{ *Resolver }
type resourcePermissionResolver struct{ *Resolver }
type roleResolver struct{ *Resolver }
