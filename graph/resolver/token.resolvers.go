package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"fmt"

	"github.com/flectolab/flecto-manager/auth"
	"github.com/flectolab/flecto-manager/common/types"
	"github.com/flectolab/flecto-manager/database"
	"github.com/flectolab/flecto-manager/graph"
	"github.com/flectolab/flecto-manager/model"
)

// CreateToken is the resolver for the createToken field.
func (r *mutationResolver) CreateToken(ctx context.Context, input graph.CreateTokenInput) (*graph.TokenCreateResponse, error) {
	userCtx := auth.GetUser(ctx)
	if !r.PermissionChecker.CanAdmin(userCtx.SubjectPermissions, model.AdminSectionTokens, model.ActionWrite) {
		return nil, fmt.Errorf("user %s has no permission to manage %s", userCtx.Username, model.AdminSectionTokens)
	}

	// Validate token name
	if !model.ValidRoleNameRegex.MatchString(input.Name) {
		return nil, fmt.Errorf("invalid token name: only alphanumeric characters, underscores and hyphens are allowed")
	}

	var expiresAt *string
	if input.ExpiresAt != nil {
		s := input.ExpiresAt.Format("2006-01-02T15:04:05Z07:00")
		expiresAt = &s
	}

	// Build permissions if provided
	var permissions *model.SubjectPermissions
	if len(input.ResourcePermissions) > 0 || len(input.AdminPermissions) > 0 {
		permissions = &model.SubjectPermissions{}
		for _, perm := range input.ResourcePermissions {
			permissions.Resources = append(permissions.Resources, model.ResourcePermission{
				Namespace: perm.Namespace,
				Project:   perm.Project,
				Resource:  model.ResourceType(perm.Resource),
				Action:    model.ActionType(perm.Action),
			})
		}
		for _, perm := range input.AdminPermissions {
			permissions.Admin = append(permissions.Admin, model.AdminPermission{
				Section: model.SectionType(perm.Section),
				Action:  model.ActionType(perm.Action),
			})
		}
	}

	token, plainToken, err := r.TokenService.Create(ctx, input.Name, expiresAt, permissions)
	if err != nil {
		return nil, err
	}

	return &graph.TokenCreateResponse{
		Token: &graph.Token{
			ID:           token.ID,
			Name:         token.Name,
			TokenPreview: token.TokenPreview,
			ExpiresAt:    token.ExpiresAt,
			CreatedAt:    token.CreatedAt,
			UpdatedAt:    token.UpdatedAt,
		},
		PlainToken: plainToken,
	}, nil
}

// UpdateTokenPermissions is the resolver for the updateTokenPermissions field.
func (r *mutationResolver) UpdateTokenPermissions(ctx context.Context, id int64, input graph.UpdateTokenPermissionsInput) (*graph.Token, error) {
	userCtx := auth.GetUser(ctx)
	if !r.PermissionChecker.CanAdmin(userCtx.SubjectPermissions, model.AdminSectionTokens, model.ActionWrite) {
		return nil, fmt.Errorf("user %s has no permission to manage %s", userCtx.Username, model.AdminSectionTokens)
	}

	// Get the token to find its role
	token, err := r.TokenService.GetByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("token not found")
	}

	// Get the role for this token
	role, err := r.TokenService.GetRole(ctx, id)
	if err != nil {
		return nil, err
	}

	// Update permissions
	subjectPermissions := &model.SubjectPermissions{}
	for _, permission := range input.ResourcePermissions {
		subjectPermissions.Resources = append(
			subjectPermissions.Resources,
			model.ResourcePermission{
				Namespace: permission.Namespace,
				Project:   permission.Project,
				Resource:  model.ResourceType(permission.Resource),
				Action:    model.ActionType(permission.Action),
			},
		)
	}
	for _, permission := range input.AdminPermissions {
		subjectPermissions.Admin = append(
			subjectPermissions.Admin,
			model.AdminPermission{
				Section: model.SectionType(permission.Section),
				Action:  model.ActionType(permission.Action),
			},
		)
	}

	err = r.RoleService.UpdateRolePermissions(ctx, role.ID, subjectPermissions)
	if err != nil {
		return nil, err
	}

	// Reload role to get updated permissions
	role, _ = r.TokenService.GetRole(ctx, id)

	return &graph.Token{
		ID:           token.ID,
		Name:         token.Name,
		TokenPreview: token.TokenPreview,
		ExpiresAt:    token.ExpiresAt,
		CreatedAt:    token.CreatedAt,
		UpdatedAt:    token.UpdatedAt,
		Role:         role,
	}, nil
}

// DeleteToken is the resolver for the deleteToken field.
func (r *mutationResolver) DeleteToken(ctx context.Context, id int64) (bool, error) {
	userCtx := auth.GetUser(ctx)
	if !r.PermissionChecker.CanAdmin(userCtx.SubjectPermissions, model.AdminSectionTokens, model.ActionWrite) {
		return false, fmt.Errorf("user %s has no permission to delete %s", userCtx.Username, model.AdminSectionTokens)
	}

	return r.TokenService.Delete(ctx, id)
}

// Tokens is the resolver for the tokens field.
func (r *queryResolver) Tokens(ctx context.Context) ([]graph.Token, error) {
	userCtx := auth.GetUser(ctx)
	if !r.PermissionChecker.CanAdmin(userCtx.SubjectPermissions, model.AdminSectionTokens, model.ActionRead) {
		return nil, fmt.Errorf("user %s has no permission to access %s", userCtx.Username, model.AdminSectionTokens)
	}

	tokens, err := r.TokenService.GetAll(ctx)
	if err != nil {
		return nil, err
	}

	result := make([]graph.Token, len(tokens))
	for i, t := range tokens {
		result[i] = graph.Token{
			ID:           t.ID,
			Name:         t.Name,
			TokenPreview: t.TokenPreview,
			ExpiresAt:    t.ExpiresAt,
			CreatedAt:    t.CreatedAt,
			UpdatedAt:    t.UpdatedAt,
		}
	}
	return result, nil
}

// Token is the resolver for the token field.
func (r *queryResolver) Token(ctx context.Context, id int64) (*graph.Token, error) {
	userCtx := auth.GetUser(ctx)
	if !r.PermissionChecker.CanAdmin(userCtx.SubjectPermissions, model.AdminSectionTokens, model.ActionRead) {
		return nil, fmt.Errorf("user %s has no permission to access %s", userCtx.Username, model.AdminSectionTokens)
	}

	token, err := r.TokenService.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}

	role, _ := r.TokenService.GetRole(ctx, id)

	return &graph.Token{
		ID:           token.ID,
		Name:         token.Name,
		TokenPreview: token.TokenPreview,
		ExpiresAt:    token.ExpiresAt,
		CreatedAt:    token.CreatedAt,
		UpdatedAt:    token.UpdatedAt,
		Role:         role,
	}, nil
}

// SearchTokens is the resolver for the searchTokens field.
func (r *queryResolver) SearchTokens(ctx context.Context, pagination *types.PaginationInput, filter graph.TokenFilter, sort []database.SortInput) (*graph.TokenList, error) {
	userCtx := auth.GetUser(ctx)
	if !r.PermissionChecker.CanAdmin(userCtx.SubjectPermissions, model.AdminSectionTokens, model.ActionRead) {
		return nil, fmt.Errorf("user %s has no permission to access %s", userCtx.Username, model.AdminSectionTokens)
	}

	query := r.TokenService.GetQuery(ctx)

	if filter.Search != nil && *filter.Search != "" {
		search := fmt.Sprintf("%%%s%%", *filter.Search)
		query = query.Where("name LIKE ? OR token_preview LIKE ?", search, search)
	}

	if len(sort) > 0 {
		query = database.ApplySort(query, model.TokenSortableColumns, sort, "")
	}

	result, err := r.TokenService.SearchPaginate(ctx, pagination, query)
	if err != nil {
		return nil, err
	}

	items := make([]graph.Token, len(result.Items))
	for i, t := range result.Items {
		items[i] = graph.Token{
			ID:           t.ID,
			Name:         t.Name,
			TokenPreview: t.TokenPreview,
			ExpiresAt:    t.ExpiresAt,
			CreatedAt:    t.CreatedAt,
			UpdatedAt:    t.UpdatedAt,
		}
	}

	return &graph.TokenList{
		Items:  items,
		Total:  result.Total,
		Limit:  result.Limit,
		Offset: result.Offset,
	}, nil
}
