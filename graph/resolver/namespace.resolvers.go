package resolver

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
	"context"
	"fmt"

	"github.com/flectolab/flecto-manager/auth"
	"github.com/flectolab/flecto-manager/common/types"
	"github.com/flectolab/flecto-manager/database"
	"github.com/flectolab/flecto-manager/graph"
	"github.com/flectolab/flecto-manager/model"
)

// CreateNamespace is the resolver for the createNamespace field.
func (r *mutationResolver) CreateNamespace(ctx context.Context, input graph.CreateNamespaceInput) (*model.Namespace, error) {
	userCtx := auth.GetUser(ctx)
	if !r.PermissionChecker.CanAdmin(userCtx.SubjectPermissions, model.AdminSectionNamespaces, model.ActionWrite) {
		return nil, fmt.Errorf("user %s has no permission to access %s", userCtx.Username, model.AdminSectionNamespaces)
	}

	newNamespace := &model.Namespace{
		NamespaceCode: input.NamespaceCode,
		Name:          input.Name,
	}

	return r.NamespaceService.Create(ctx, newNamespace)
}

// UpdateNamespace is the resolver for the updateNamespace field.
func (r *mutationResolver) UpdateNamespace(ctx context.Context, namespaceCode string, input graph.UpdateNamespaceInput) (*model.Namespace, error) {
	userCtx := auth.GetUser(ctx)
	if !r.PermissionChecker.CanAdmin(userCtx.SubjectPermissions, model.AdminSectionNamespaces, model.ActionWrite) {
		return nil, fmt.Errorf("user %s has no permission to access %s", userCtx.Username, model.AdminSectionNamespaces)
	}

	return r.NamespaceService.Update(ctx, namespaceCode, model.Namespace{Name: input.Name})
}

// DeleteNamespace is the resolver for the deleteNamespace field.
func (r *mutationResolver) DeleteNamespace(ctx context.Context, namespaceCode string) (bool, error) {
	userCtx := auth.GetUser(ctx)
	if !r.PermissionChecker.CanAdmin(userCtx.SubjectPermissions, model.AdminSectionNamespaces, model.ActionWrite) {
		return false, fmt.Errorf("user %s has no permission to access %s", userCtx.Username, model.AdminSectionNamespaces)
	}

	return r.NamespaceService.Delete(ctx, namespaceCode)
}

// Projects is the resolver for the projects field.
func (r *namespaceResolver) Projects(ctx context.Context, obj *model.Namespace) ([]model.Project, error) {
	userCtx := auth.GetUser(ctx)
	query := r.ProjectService.GetQuery(ctx)
	query = r.PermissionChecker.FilterQueryByProject(query, userCtx.SubjectPermissions.Resources, obj.NamespaceCode, model.ActionRead)

	return r.ProjectService.Search(ctx, query)
}

// Namespaces is the resolver for the namespaces field.
func (r *queryResolver) Namespaces(ctx context.Context) ([]model.Namespace, error) {
	userCtx := auth.GetUser(ctx)
	query := r.NamespaceService.GetQuery(ctx)
	query = r.PermissionChecker.FilterQueryByNamespace(query, userCtx.SubjectPermissions.Resources, model.ActionRead)
	namespaces := make([]model.Namespace, 0)
	err := query.Find(&namespaces).Error
	if err != nil {
		return nil, err
	}
	return namespaces, nil
}

// Namespace is the resolver for the namespace field.
func (r *queryResolver) Namespace(ctx context.Context, namespaceCode string) (*model.Namespace, error) {
	userCtx := auth.GetUser(ctx)
	if !r.PermissionChecker.CanAdmin(userCtx.SubjectPermissions, model.AdminSectionNamespaces, model.ActionRead) &&
		!r.PermissionChecker.CanResource(userCtx.SubjectPermissions, namespaceCode, "*", model.ResourceTypeAny, model.ActionRead) {
		return nil, fmt.Errorf("user %s has no permission to access namespace %s", userCtx.Username, namespaceCode)
	}
	return r.NamespaceService.GetByCode(ctx, namespaceCode)
}

// SearchNamespaces is the resolver for the searchNamespaces field.
func (r *queryResolver) SearchNamespaces(ctx context.Context, pagination *types.PaginationInput, filter graph.NamespaceFilter, sort []database.SortInput) (*types.PaginatedResult[model.Namespace], error) {
	userCtx := auth.GetUser(ctx)
	query := r.NamespaceService.GetQuery(ctx)
	if !r.PermissionChecker.CanAdmin(userCtx.SubjectPermissions, model.AdminSectionNamespaces, model.ActionRead) {
		query = r.PermissionChecker.FilterQueryByNamespace(query, userCtx.SubjectPermissions.Resources, model.ActionRead)
	}

	if filter.Search != nil && *filter.Search != "" {
		search := fmt.Sprintf("%%%s%%", *filter.Search)
		query = query.Where(fmt.Sprintf("%s LIKE ? OR name LIKE ?", model.ColumnNamespaceCode), search, search)
	}

	if len(sort) > 0 {
		query = database.ApplySort(query, model.NamespaceSortableColumns, sort, "")
	}

	return r.NamespaceService.SearchPaginate(ctx, pagination, query)
}

// Namespace returns graph.NamespaceResolver implementation.
func (r *Resolver) Namespace() graph.NamespaceResolver { return &namespaceResolver{r} }

type namespaceResolver struct{ *Resolver }
